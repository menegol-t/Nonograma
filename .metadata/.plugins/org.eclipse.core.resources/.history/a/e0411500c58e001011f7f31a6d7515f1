package logica;

public class Main
{
	public static void main(String[] args) {
		int[][] matrix = {
	      {1, 0, 1, 0, 1},
	      {1, 1, 1, 1, 0},
	      {0, 0, 0, 0, 0},
	      {1, 0, 0, 0, 1},
	      {1, 0, 0, 1, 1}
		};
  
		int[][] mat = generarReferenciaFilas(matrix);
  
		imprimirMatriz(mat);

	}
	
	public static int[][] generarReferenciaFilas(int[][] tableroConCasillasNegras)
	{
	    //Si el tablero mide 5 necesito 3 espacios para repsentar el peor caso de celdas marcadas, si el tablero mide 15 neceisto 8, si el tablero mide 20 necesito 10
	    int cantidadDeNumerosPorReferencia = (tableroConCasillasNegras.length + 1) / 2;
	    
	    //Lista 5*3 donde guardo las referencias 
	    int [][] referenciasCalculadas = new int [tableroConCasillasNegras.length][cantidadDeNumerosPorReferencia];
	    
	    //Recorro todas las filas
	    for(int i = 0; i <= tableroConCasillasNegras.length - 1; i++)
	    {
	        
	        boolean celdaAnteriorFueNegra = false;
	        
	        int indiceReferenciasCalculadas = 0, acumCeldasNegrasPorFila = 0;
	        
	        //Dentro de cada fila, recorro todas sus celdas buscando aquellas con "1" (es decir, marcadas)
	        for(int j = 0; j <= tableroConCasillasNegras[0].length - 1; j++)
	        {
	        	//Si encontre una celda con una casilla negra, aumento el acumulador
	            if(tableroConCasillasNegras[i][j] == 1)
	            {
	            	//Acumulo la cantidad de celdas negras que llevo seguidas, por ej [1,1,1,1,0] voy acumulando 4.
	            	acumCeldasNegrasPorFila ++;
	                
	                //Me ayuda a despues a decidir si cortar el acumulador o no, por ejemplo [1,0,1,0,1] deberia darme la referencia [1,1,1], no [3]
	                celdaAnteriorFueNegra = true;
	            }
	            
	            //Si la celda actual no es negra y ademas la celda anterior SI FUE NEGRA, es decir, si tengo 2 celdas blancas seguidas y esta es la segunda, lo siguiente no se ejecuta 
	            else if(celdaAnteriorFueNegra)
	            {
	               //Si la celda anterior fue negra, y esta ya no, guardo lo que el acumulador guardo desde la iteracion anterior
	               referenciasCalculadas[i][indiceReferenciasCalculadas] = acumCeldasNegrasPorFila;
	                
	               //Una vez guardado, como esta celda no es negra, corto el acumulador reiniciandolo. Si tengo la fila [1,1,0,1], esto se da cuando me paro en "0". En la linea anterior guardÃ© el acumulador cuando estaba acumuladndo "2"
	               acumCeldasNegrasPorFila = 0;
	                
//	               //Con el acumulador cortado, preparo para que la siguiente referencia se guarde en el proximo indice del array de referencias por fila []
//	               indiceReferenciasCalculadas ++;
	               celdaAnteriorFueNegra = false;
	            }
//	            else
//	            {
//	            	celdaAnteriorFueNegra = false;
//	            }
	            
	        }
	        
	        /*
	         * Lo de arriba solo guarda el acumulador en la referencia si la celda anterior no fue "1", es decir si se da que [1,1,0]. 
	         * Si justo la ultima celda esta marcada, es decir [1,0,1], no se guarda el ultimo 1. Para eso esta este if. Una vez
	         * finalice de recorrer la fila, si la anterior fue negra, guardo ese acumulador.
	         */
	        if(celdaAnteriorFueNegra) referenciasCalculadas[i][indiceReferenciasCalculadas] = acumCeldasNegrasPorFila;
	        
	    }
	    
	    return referenciasCalculadas;
	}
	
	public static void imprimirMatriz(int[][] mat) 
    {
        for (int i = 0; i < mat.length; i++) 
        {
            for (int j = 0; j < mat[i].length; j++) 
            {
                System.out.print(mat[i][j] + " ");
            }
            System.out.println();
        }
    }
}