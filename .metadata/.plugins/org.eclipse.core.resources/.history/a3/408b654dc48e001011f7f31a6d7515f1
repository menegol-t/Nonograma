package logica;

public class Main
{
	public static void main(String[] args) {
		int[][] matrix = {
	      {1, 0, 1, 0, 1},
	      {1, 1, 1, 1, 0},
	      {0, 0, 0, 0, 0},
	      {1, 0, 0, 0, 1},
	      {1, 0, 0, 1, 1}
		};
  
		int[][] mat = generarReferenciaFilas(matrix);
  
		imprimirMatriz(mat);

	}
	
	public static int[][] generarReferenciaFilas(int[][] tableroConCasillasNegras)
	{
	    //Si el tablero mide 5 necesito 3 espacios para repsentar el peor caso de celdas marcadas, si el tablero mide 15 neceisto 8, si el tablero mide 20 necesito 10
	    int cantidadDeNumerosPorReferencia = (tableroConCasillasNegras.length + 1) / 2;
	    
	    //Lista 5*3 donde guardo las referencias 
	    int [][] referenciasCalculadas = new int [tableroConCasillasNegras.length][cantidadDeNumerosPorReferencia];
	    
	    //Acum de celdas marcadas
	    int acumuladorDeCeldasNegrasPorFila = 0;
	    
	    //Me ayuda a cortar el acumulador de celdas marcadas por fila paar las referencias. Por ej si tengo en el tablero [1,1,0,0,1], esto me ayuda a que la referencia sea [2,1] en lugar de [3]
	    boolean anteriorFueCeldaNegra;
	    
	    //Indice dentro del array de referencia por fila
	    int posicionArrayReferenciasCalculadas = 0;
	    
	    //Recorro todas las filas
	    for(int i = 0; i <= tableroConCasillasNegras.length - 1; i++)
	    {
	        
	        anteriorFueCeldaNegra = false;
	        
	        posicionArrayReferenciasCalculadas = 0;
	        
	        acumuladorDeCeldasNegrasPorFila = 0;
	        
	        //Dentro de cada fila, recorro todas sus celdas buscando aquellas con "1" (es decir, marcadas)
	        for(int j = 0; j <= tableroConCasillasNegras[0].length - 1; j++)
	        {
	        	//Si encontre una celda con una casilla negra, aumento el acumulador
	            if(tableroConCasillasNegras[i][j] == 1)
	            {
	            	//Acumulo la cantidad de celdas negras que llevo seguidas, por ej [1,1,1,1,0] voy acumulando 4.
	                acumuladorDeCeldasNegrasPorFila ++;
	                
	                //Me ayuda a despues a decidir si cortar el acumulador o no, por ejemplo [1,0,1,0,1] deberia darme la referencia [1,1,1], no [3]
	                anteriorFueCeldaNegra = true;
	            }
	            
	            //Si la celda actual no es negra
	            else 
	            {
	            	//y ademas la celda anterior SI FUE NEGRA, es decir, si tengo 2 celdas blancas seguidas y esta es la segunda, lo siguiente no se ejecuta 
	                if(anteriorFueCeldaNegra)
	                {
	                	//Si la celda anterior fue negra, y esta ya no, guardo lo que el acumulador guardo desde la iteracion anterior
	                    referenciasCalculadas[i][posicionArrayReferenciasCalculadas] = acumuladorDeCeldasNegrasPorFila;
	                
	                    //Una vez guardado, como esta celda no es negra, corto el acumulador reiniciandolo. Si tengo la fila [1,1,0,1], esto se da cuando me paro en "0". En la linea anterior guardÃ© el acumulador cuando estaba acumuladndo "2"
	                    acumuladorDeCeldasNegrasPorFila = 0;
	                
	                    //Con el acumulador cortado, preparo para que la siguiente referencia se guarde en el proximo indice del array de referencias por fila []
	                    posicionArrayReferenciasCalculadas ++;
	                }
	                
	                anteriorFueCeldaNegra = false;
	            }
	            
	        }
	        
	        /*
	         * Lo de arriba solo guarda el acumulador en la referencia si la celda anterior no fue "1", es decir si se da que [1,1,0]. 
	         * Si justo la ultima celda esta marcada, es decir [1,0,1], no se guarda el ultimo 1. Para eso esta este if. Una vez
	         * finalice de recorrer la fila, si la anterior fue negra, guardo ese acumulador.
	         */
	        if(anteriorFueCeldaNegra)
	        {
	            referenciasCalculadas[i][posicionArrayReferenciasCalculadas] = acumuladorDeCeldasNegrasPorFila;
	        }
	    }
	    
	    return referenciasCalculadas;
	}
	
	public static void imprimirMatriz(int[][] mat) 
    {
        for (int i = 0; i < mat.length; i++) 
        {
            for (int j = 0; j < mat[i].length; j++) 
            {
                System.out.print(mat[i][j] + " ");
            }
            System.out.println();
        }
    }
}